<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Poker My Mind – Preflop Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #05060a;
      --bg-alt: #10121b;
      --card-bg: #151827;
      --accent: #27c9a8;
      --accent-soft: rgba(39, 201, 168, 0.14);
      --danger: #ff5370;
      --text: #f8f9ff;
      --muted: #a3aec7;
      --border: #26293a;
      --font: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(circle at top, #14172a, #05060a 55%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    .app-shell {
      max-width: 900px;
      margin: 0 auto;
      padding: 1.25rem 1rem 2.5rem;
    }

    @media (min-width: 768px) {
      .app-shell {
        padding: 2rem 1.5rem 3rem;
      }
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .logo {
      width: 40px;
      height: 40px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(circle at 20% 0%, rgba(39,201,168,0.4), transparent 55%),
        radial-gradient(circle at 75% 100%, rgba(114,137,252,0.4), transparent 55%),
        #05060a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: -0.04em;
      box-shadow:
        0 0 0 1px rgba(0,0,0,0.6),
        0 18px 35px rgba(0,0,0,0.7);
    }

    .brand-title {
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .brand-name {
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .tagline {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 0.15rem;
    }

    .nav {
      display: inline-flex;
      background: rgba(8,10,20,0.85);
      border-radius: 999px;
      padding: 0.18rem;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 12px 25px rgba(0,0,0,0.55);
    }

    .nav button {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.18s ease-out;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
    }

    .nav button.active {
      background: linear-gradient(135deg, var(--accent), #58d1ff);
      color: #05060a;
      box-shadow: 0 6px 18px rgba(39,201,168,0.45);
    }

    main {
      display: grid;
      gap: 1rem;
    }

    .card {
      background: linear-gradient(145deg, rgba(18,20,36,0.98), rgba(6,8,16,0.98));
      border-radius: 20px;
      padding: 1rem;
      border: 1px solid var(--border);
      box-shadow:
        0 18px 40px rgba(0,0,0,0.7),
        0 0 0 1px rgba(255,255,255,0.02);
    }

    @media (min-width: 768px) {
      .card {
        padding: 1.25rem 1.4rem;
      }
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.5rem;
      margin-bottom: 0.6rem;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.7rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }

    .form-grid {
      display: grid;
      gap: 0.8rem;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    label {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
    }

    select, input[type="number"] {
      width: 100%;
      padding: 0.55rem 0.7rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(6,8,16,0.95);
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
      appearance: none;
    }

    select:focus, input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(39,201,168,0.35);
      background: rgba(13,17,30,0.98);
    }

    .hand-row {
      display: flex;
      gap: 0.6rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .hand-preview {
      font-family: "JetBrains Mono", "SF Mono", ui-monospace, monospace;
      font-size: 0.9rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.09);
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .hand-preview span {
      opacity: 0.7;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .actions-row {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .action-btn {
      flex: 1 0 0;
      min-width: 0;
      padding: 0.5rem 0.6rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(5,8,16,0.98);
      color: var(--muted);
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      transition: all 0.16s ease-out;
    }

    .action-btn.selected {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(39,201,168,0.28);
    }

    .action-btn.disabled {
      opacity: 0.45;
      cursor: not-allowed;
      border-style: dashed;
    }

    .primary-btn {
      margin-top: 0.5rem;
      width: 100%;
      padding: 0.6rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #58d1ff);
      color: #05060a;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(39,201,168,0.4);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, filter 0.08s ease-out;
    }

    .primary-btn:active {
      transform: translateY(1px);
      box-shadow: 0 6px 18px rgba(39,201,168,0.35);
      filter: brightness(0.97);
    }

    .primary-btn.disabled {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
      filter: grayscale(0.2) brightness(0.85);
    }

    .ghost-btn {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(4,6,12,0.8);
      color: var(--muted);
      font-size: 0.78rem;
      padding: 0.3rem 0.75rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      font-weight: 600;
      transition: all 0.16s ease-out;
    }

    .ghost-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .result {
      margin-top: 0.8rem;
      padding: 0.75rem 0.85rem;
      border-radius: 14px;
      background: rgba(5,9,20,0.95);
      border: 1px solid rgba(255,255,255,0.06);
      display: grid;
      gap: 0.5rem;
    }

    .grade-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.55rem;
      align-items: center;
    }

    .grade-pill {
      display: inline-flex;
      align-items: baseline;
      gap: 0.4rem;
      padding: 0.35rem 0.6rem;
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
    }

    .grade-letter {
      font-size: 1.4rem;
      font-weight: 800;
      letter-spacing: 0.06em;
    }

    .grade-context {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .grade-badge-good {
      color: var(--accent);
    }

    .grade-badge-bad {
      color: var(--danger);
    }

    .grade-recommendation {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .odds-block {
      background: radial-gradient(circle at 20% 20%, rgba(39,201,168,0.18), rgba(39,201,168,0.04)),
        rgba(255,255,255,0.03);
      border: 1px solid rgba(39,201,168,0.3);
      border-radius: 12px;
      padding: 0.7rem 0.75rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
      display: grid;
      gap: 0.25rem;
    }

    .odds-headline {
      font-size: 1.2rem;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .odds-subline {
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.45;
    }

    .recommendation {
      font-size: 0.92rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .explanation {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.45;
    }

    .two-col {
      display: grid;
      gap: 0.8rem;
    }

    @media (min-width: 640px) {
      .two-col {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .muted-note {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 0.4rem;
    }

    .small-note {
      font-size: 0.76rem;
      color: var(--muted);
      opacity: 0.8;
    }

    .about-text {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.45;
    }

    .about-text strong {
      color: var(--text);
    }

    footer {
      margin-top: 1.4rem;
      font-size: 0.75rem;
      color: var(--muted);
      text-align: center;
      opacity: 0.7;
    }

    /* Scenario strip & cards */
    .scenario-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: space-between;
    }

    .scenario-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.22rem 0.7rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: var(--muted);
    }

    .scenario-pill strong {
      color: var(--text);
      letter-spacing: 0.06em;
    }

    .card-strip {
      margin-top: 0.25rem;
      display: flex;
      gap: 0.85rem;
      align-items: center;
    }

    .poker-card {
      width: 82px;
      height: 114px;
      border-radius: 16px;
      background:
        radial-gradient(circle at 15% 10%, rgba(255,255,255,0.24), transparent 55%),
        radial-gradient(circle at 85% 90%, rgba(88,209,255,0.16), transparent 55%),
        var(--card-bg);
      border: 1px solid rgba(255,255,255,0.28);
      box-shadow:
        0 0 18px rgba(39,201,168,0.24),
        0 10px 24px rgba(0,0,0,0.75);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .poker-card::before {
      content: '';
      position: absolute;
      inset: 1px;
      border-radius: 15px;
      border: 1px solid rgba(0,0,0,0.55);
      pointer-events: none;
    }

    .poker-rank {
      font-size: 1.9rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      margin-bottom: 0.1rem;
    }

    .poker-suit {
      font-size: 1.35rem;
    }

    .poker-suit.red {
      color: #ff6b8b;
    }

    .card-row-info {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .position-helper {
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(5,7,14,0.9);
      display: grid;
      gap: 0.6rem;
    }

    .position-helper-header {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .table-diagram {
      position: relative;
      width: 100%;
      max-width: 320px;
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      background: radial-gradient(circle at 50% 50%, rgba(39,201,168,0.1), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 50%;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
      overflow: hidden;
    }

    .seat {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 92px;
      height: 56px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(4,6,12,0.9);
      display: grid;
      place-items: center;
      text-align: center;
      padding: 0.35rem;
      transition: all 0.18s ease-out;
      color: var(--muted);
      transform: translate(-50%, -50%) rotate(var(--angle, 0deg)) translateY(-46%) rotate(calc(-1 * var(--angle, 0deg)));
    }

    .seat.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(39,201,168,0.35), 0 14px 30px rgba(0,0,0,0.5);
      color: var(--text);
      background: linear-gradient(135deg, rgba(39,201,168,0.18), rgba(39,201,168,0.08));
    }

    .seat-code {
      font-weight: 800;
      letter-spacing: 0.06em;
    }

    .seat-desc {
      font-size: 0.78rem;
      opacity: 0.85;
    }

    .position-explainer {
      display: grid;
      gap: 0.35rem;
      text-align: center;
    }

    .position-chip {
      display: inline-flex;
      margin: 0 auto;
      padding: 0.2rem 0.7rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--text);
    }

    .position-note {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.45;
    }

    .table-diagram .seat[data-pos="BTN"] { --angle: -90deg; }
    .table-diagram .seat[data-pos="CO"] { --angle: -30deg; }
    .table-diagram .seat[data-pos="MP"] { --angle: 30deg; }
    .table-diagram .seat[data-pos="UTG"] { --angle: 90deg; }
    .table-diagram .seat[data-pos="BB"] { --angle: 150deg; }
    .table-diagram .seat[data-pos="SB"] { --angle: 210deg; }

    .table-arrow {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 58%;
      height: 58%;
      border: 2px solid rgba(255,255,255,0.08);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-color: transparent transparent rgba(255,255,255,0.16) rgba(255,255,255,0.16);
    }

    .table-arrow::after {
      content: '';
      position: absolute;
      bottom: 8%;
      right: 14%;
      width: 12px;
      height: 12px;
      border-top: 2px solid rgba(255,255,255,0.16);
      border-right: 2px solid rgba(255,255,255,0.16);
      transform: rotate(45deg);
    }

    /* Auto deal UI */
    .auto-deal {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .auto-toggle {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(4,6,12,0.8);
      color: var(--muted);
      font-size: 0.75rem;
      padding: 0.18rem 0.8rem;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      font-weight: 600;
      transition: all 0.16s ease-out;
    }

    .auto-toggle.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(39,201,168,0.35);
    }

    .auto-timer {
      margin-top: 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .auto-timer-track {
      flex: 1;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      overflow: hidden;
    }

    .auto-timer-bar {
      height: 100%;
      width: 0;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent), #58d1ff);
      transform-origin: left center;
    }

    .auto-timer-label {
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="brand">
        <div class="logo">PM</div>
        <div>
          <div class="brand-title">Poker Training</div>
          <div class="brand-name">Poker My Mind</div>
          <div class="tagline">Judge your decisions, not your luck.</div>
        </div>
      </div>
      <nav class="nav">
        <button data-tab="preflop" class="active">Preflop Trainer</button>
        <button data-tab="potodds">Pot Odds</button>
        <button data-tab="about">About</button>
      </nav>
    </header>

    <main>
      <!-- Preflop Trainer -->
      <section id="tab-preflop" class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Preflop Trainer</div>
            <div class="card-subtitle">
              Get dropped into a random spot, choose your move, and see if it was a good decision – before any flop.
            </div>
          </div>
          <span class="pill">Random scenario · Unopened pot</span>
        </div>

        <div class="form-grid">
          <div>
            <div class="field-group">
              <label>Scenario</label>
              <div class="scenario-row">
                <div class="scenario-pill" id="scenarioPosition">
                  POS: <strong>BTN</strong>
                </div>
                <div class="auto-deal">
                  <span class="small-note">Auto deal if A</span>
                  <button type="button" class="auto-toggle" id="autoDealToggle" aria-pressed="false">Off</button>
                </div>
              </div>
              <div class="small-note">
                Unopened cash-game pot. Blinds posted, action is on you preflop.
              </div>
            </div>

            <div class="field-group">
              <label>Dealt cards</label>
              <div class="card-strip">
                <div class="poker-card" id="card1">
                  <div class="poker-rank" id="card1Rank">A</div>
                  <div class="poker-suit" id="card1Suit">♠</div>
                </div>
                <div class="poker-card" id="card2">
                  <div class="poker-rank" id="card2Rank">A</div>
                  <div class="poker-suit" id="card2Suit">♥</div>
                </div>
                <div class="card-row-info">
                  <div class="hand-preview" id="handPreview">
                    <span>Hand</span>
                    <strong>AA</strong>
                  </div>
                  <div class="small-note">Cards glow, you decide: fold, check, limp, or open-raise.</div>
                </div>
              </div>
            </div>

            <div class="field-group">
              <label>Your action</label>
              <div class="actions-row" id="actionButtons">
                <button type="button" class="action-btn" data-action="FOLD">Fold</button>
                <button type="button" class="action-btn" data-action="CHECK" id="checkBtn" style="display:none;">Check</button>
                <button
                  type="button"
                  class="action-btn"
                  data-action="CALL"
                  id="callBtn"
                  title="Limping = calling the big blind preflop instead of raising. In the BB with no raise, you check instead of calling."
                >
                  Call / Limp
                </button>
                <button type="button" class="action-btn" data-action="RAISE">Raise / Open</button>
              </div>
            </div>

            <div class="result" id="resultBox">
              <div class="grade-line">
                <div class="grade-pill">
                  <span class="grade-letter grade-badge-good" id="gradeLetter">A</span>
                  <span class="grade-context" id="gradeContext">Solid open.</span>
                </div>
                <div class="grade-recommendation" id="recommendation">
                  Recommended: Raise this hand from BTN.
                </div>
              </div>
              <div class="odds-block" aria-live="polite">
                <div class="odds-headline" id="oddsHeadline">Win chance: –</div>
                <div class="odds-subline" id="oddsSubline">
                  Pick an action to see how often this hand is expected to win in this spot.
                </div>
              </div>
              <p class="explanation" id="explanation">
                Deal a hand, pick your action, then see whether you played too tight, too loose, or just right based on
                baseline open-raise ranges.
              </p>
            </div>

            <div class="position-helper" aria-label="Table position guide">
              <div class="position-helper-header">Where you're sitting</div>
              <div class="table-diagram" id="tableDiagram">
                <div class="table-arrow" aria-hidden="true"></div>
                <div class="seat" data-pos="BTN">
                  <div class="seat-code">BTN</div>
                  <div class="seat-desc">Dealer / Button</div>
                </div>
                <div class="seat" data-pos="CO">
                  <div class="seat-code">CO</div>
                  <div class="seat-desc">Cutoff – Late</div>
                </div>
                <div class="seat" data-pos="MP">
                  <div class="seat-code">MP</div>
                  <div class="seat-desc">Middle Position</div>
                </div>
                <div class="seat" data-pos="UTG">
                  <div class="seat-code">UTG</div>
                  <div class="seat-desc">First to act</div>
                </div>
                <div class="seat" data-pos="BB">
                  <div class="seat-code">BB</div>
                  <div class="seat-desc">Big Blind</div>
                </div>
                <div class="seat" data-pos="SB">
                  <div class="seat-code">SB</div>
                  <div class="seat-desc">Small Blind</div>
                </div>
              </div>
              <div class="position-explainer">
                <div class="position-chip" id="positionChip">BTN – Dealer/Button</div>
                <div class="position-note" id="positionNote">
                  You act last after the flop, so you can play more hands here.
                </div>
              </div>
            </div>

            <button class="primary-btn" id="primaryBtn">
              Evaluate Decision
              <span>→</span>
            </button>
            <div class="auto-timer" id="autoDealTimer" style="display:none;">
              <div class="auto-timer-track">
                <div class="auto-timer-bar" id="autoDealBar"></div>
              </div>
              <span class="auto-timer-label">Next hand in 2s…</span>
            </div>
        </div>
      </section>

      <!-- Pot Odds -->
      <section id="tab-potodds" class="card" style="display:none;">
        <div class="card-header">
          <div>
            <div class="card-title">Pot Odds Helper</div>
            <div class="card-subtitle">
              Quick math to check if a call with a draw makes sense.
            </div>
          </div>
          <span class="pill">Math · Single-street</span>
        </div>

        <div class="two-col">
          <div class="form-grid">
            <div class="field-group">
              <label for="potSize">Pot size before villain bets</label>
              <input type="number" id="potSize" min="0" step="0.01" placeholder="e.g. 10" />
            </div>
            <div class="field-group">
              <label for="betSize">Bet you’re facing</label>
              <input type="number" id="betSize" min="0" step="0.01" placeholder="e.g. 5" />
            </div>
            <div class="field-group">
              <label for="outs">Your number of outs</label>
              <input type="number" id="outs" min="0" max="20" step="1" placeholder="e.g. 9 for a flush draw" />
            </div>
            <button class="primary-btn" id="calculateOddsBtn">
              Calculate Pot Odds
              <span>≈</span>
            </button>
          </div>
          <div>
            <div class="result" id="oddsResultBox">
              <div class="grade-pill">
                <span class="grade-letter" id="oddsSummary">–</span>
                <span class="grade-context">Pot odds vs draw odds</span>
              </div>
              <div class="explanation" id="oddsExplanation">
                Enter the pot size, bet size you’re facing, and your approximate outs.
                You’ll see:
                <ul style="margin: 0.4rem 0 0 1.1rem; padding: 0; font-size: 0.85rem;">
                  <li>Pot odds (% you need to break even)</li>
                  <li>Approximate equity from your outs</li>
                  <li>Whether a call is roughly +EV or -EV</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <p class="muted-note">
          Note: This is a simple one-street estimate. Real hands require implied odds, reverse implied odds, and ranges,
          but this keeps your baseline math honest.
        </p>
      </section>

      <!-- About -->
      <section id="tab-about" class="card" style="display:none;">
        <div class="card-header">
          <div>
            <div class="card-title">About Poker My Mind</div>
            <div class="card-subtitle">
              A proof-of-concept trainer focused on decision quality over short-term results.
            </div>
          </div>
          <span class="pill">Prototype · v0.5</span>
        </div>
        <div class="about-text">
          <p>
            <strong>Poker My Mind</strong> is built around one core idea:
            judge your poker by the quality of your decisions, not by the luck of the runout.
          </p>
          <p>
            This prototype deals you random preflop scenarios in unopened pots, lets you pick an action, and grades
            your choice against simple open-raise ranges by position.
          </p>
          <p>
            It includes:
          </p>
          <ul>
            <li>Random hand + position generator</li>
            <li>One evaluation per hand (no spammy retries)</li>
            <li>Big blind-specific “Check vs limp” teaching</li>
            <li>Auto Deal mode with a 2s cadence for fast reps</li>
            <li>A basic pot odds helper for draw math</li>
          </ul>
          <p>
            Future steps: facing opens & 3-bets, postflop decisions, and full hand review with leak analysis.
          </p>
        </div>
      </section>
    </main>

    <footer>
      Poker My Mind · Prototype trainer – not a real-time assistance tool for any specific poker site or casino.
      Always follow the rules of your cardroom.
    </footer>
  </div>

  <script>
    // ---------- Tabs ----------
    const tabs = document.querySelectorAll('.nav button');
    const sections = {
      preflop: document.getElementById('tab-preflop'),
      potodds: document.getElementById('tab-potodds'),
      about: document.getElementById('tab-about'),
    };

    tabs.forEach(btn => {
      btn.addEventListener('click', () => {
        tabs.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const tab = btn.dataset.tab;
        Object.entries(sections).forEach(([key, el]) => {
          el.style.display = key === tab ? 'block' : 'none';
        });
      });
    });

    // ---------- Preflop logic ----------
    const rankOrder = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];
    const openRangesByPosition = {
      UTG: [
        'AA','KK','QQ','JJ','1010','99',
        'AKs','AQs','AJs','KQs',
        'AKo','AQo',
      ],
      MP: [
        'AA','KK','QQ','JJ','1010','99','88','77',
        'AKs','AQs','AJs','A10s','KQs','KJs','QJs',
        'AKo','AQo','KQo',
      ],
      CO: [
        'AA','KK','QQ','JJ','1010','99','88','77','66','55','44','33','22',
        'AKs','AQs','AJs','A10s','A9s','A8s',
        'KQs','KJs','K10s',
        'QJs','Q10s','J10s','109s','98s',
        'AKo','AQo','AJo','KQo','KJo','QJo',
      ],
      BTN: [
        'AA','KK','QQ','JJ','1010','99','88','77','66','55','44','33','22',
        'AKs','AQs','AJs','A10s','A9s','A8s','A7s','A6s','A5s','A4s','A3s','A2s',
        'KQs','KJs','K10s','K9s',
        'QJs','Q10s','Q9s',
        'J10s','J9s',
        '109s','108s',
        '98s','97s','87s','76s','65s',
        'AKo','AQo','AJo','A10o','A9o',
        'KQo','KJo','K10o',
        'QJo','Q10o',
        'J10o',
      ],
      SB: [
        'AA','KK','QQ','JJ','1010','99','88','77','66','55',
        'AKs','AQs','AJs','A10s','A9s','A8s',
        'KQs','KJs','K10s',
        'QJs','Q10s','J10s','109s','98s',
        'AKo','AQo','AJo','KQo','KJo','QJo',
      ],
      BB: [
        'AA','KK','QQ','JJ','1010','99','88','77',
        'AKs','AQs','AJs','A10s','KQs','KJs',
        'QJs','J10s','109s',
        'AKo','AQo','AJo','KQo',
      ],
    };

    function canonicalHand(rank1, rank2, suitedFlag) {
      if (rank1 === rank2) {
        return rank1 + rank2; // pairs: AA, KK, etc.
      }
      const idx1 = rankOrder.indexOf(rank1);
      const idx2 = rankOrder.indexOf(rank2);
      const high = idx1 <= idx2 ? rank1 : rank2;
      const low = idx1 <= idx2 ? rank2 : rank1;
      return `${high}${low}${suitedFlag}`;
    }

    function parseHandCode(hand) {
      const suited = hand.endsWith('s');
      const offsuit = hand.endsWith('o');
      const rankPart = suited || offsuit ? hand.slice(0, -1) : hand;
      const match = rankPart.match(/(10|[AKQJ2-9])(10|[AKQJ2-9])/);
      const ranks = match ? [match[1], match[2]] : [rankPart[0], rankPart[1] || rankPart[0]];
      const pair = ranks[0] === ranks[1];
      const connectors =
        !pair && Math.abs(rankOrder.indexOf(ranks[0]) - rankOrder.indexOf(ranks[1])) === 1;
      const broadwayRanks = ['A', 'K', 'Q', 'J', '10'];
      const broadway = ranks.every((r) => broadwayRanks.includes(r));

      return { suited, offsuit, pair, connectors, broadway, ranks };
    }

    function percentToFrequencyText(percent) {
      const winsOutOfTen = Math.min(10, Math.max(1, Math.round(percent / 10)));
      return `about ${winsOutOfTen} out of 10 times`;
    }

    function estimateWinChance(hand, position, isInOpenRange) {
      const traits = parseHandCode(hand);
      const rankIndexes = traits.ranks.map((r) => rankOrder.indexOf(r)).sort((a, b) => a - b);
      const bestIdx = rankIndexes[0];
      let score = 18 + Math.max(0, (12 - bestIdx) * 1.8);

      if (traits.pair) score += 18;
      if (traits.suited) score += 6;
      if (traits.connectors) score += 5;
      if (traits.broadway) score += 4;
      if (isInOpenRange) score += 6;

      const positionAdjust = { BTN: 10, CO: 7, MP: 3, UTG: 0, SB: -2, BB: 2 };
      score += positionAdjust[position] || 0;

      const clamped = Math.min(88, Math.max(8, Math.round(score)));
      return clamped;
    }

    function buildOddsNarrative(percent, position, action) {
      if (percent >= 65) {
        return 'You will win this hand often here, so choosing the stronger option keeps the pressure on your opponents.';
      }
      if (percent >= 50) {
        return 'You come out ahead a lot, especially when you guide the pot. Lean into the solid choice for this seat.';
      }
      if (percent >= 35) {
        return 'You will win sometimes, but not often. A cautious option from this seat protects your stack.';
      }
      return action === 'FOLD'
        ? 'This hand wins rarely from this position. Folding is the safe, disciplined move.'
        : 'You are not favored to win here. Picking the tight option keeps you out of tough spots.';
    }

    function buildPreflopExplanation({ hand, position, action, isInOpenRange }) {
      const traits = parseHandCode(hand);
      const reasons = [];

      const positionAdvice = {
        BTN: 'Acting last after the flop lets you control the pace of the hand.',
        CO: 'Late position means you see most players act before you.',
        MP: 'Middle position still has several players to act, so be steady.',
        UTG: 'First to act preflop, so choose stronger starting hands.',
        SB: 'Small blind pays a chip and acts early later, so tighter play helps.',
        BB: 'Big blind already paid a chip; checking for free keeps that advantage.',
      };

      if (action === 'CHECK' && position === 'BB') {
        reasons.push('You can see a flop for free, so checking keeps the risk low.');
      } else if (action === 'RAISE') {
        if (isInOpenRange) {
          reasons.push('This hand is strong enough to open confidently from here.');
        } else {
          reasons.push('Raising is adventurous with this hand from this seat.');
        }
      } else if (action === 'FOLD') {
        if (isInOpenRange) {
          reasons.push('Folding skips a hand that is usually playable from this position.');
        } else {
          reasons.push('Folding keeps you out of trouble with a weak start.');
        }
      } else if (action === 'CALL') {
        reasons.push('Calling here is passive and can leave you guessing after the flop.');
      }

      if (traits.pair) {
        reasons.push('Pairs can win at showdown even when you miss the flop.');
      }
      if (traits.broadway) {
        reasons.push('High cards often make top pair with a solid kicker.');
      }
      if (traits.connectors) {
        reasons.push('Neighboring ranks like these can turn into straights.');
      }
      if (traits.suited) {
        reasons.push('Matching suits add extra ways to make a flush.');
      }

      reasons.push(positionAdvice[position]);

      return reasons.filter(Boolean).join(' ');
    }

    function evaluatePreflopOpen(position, hand, userAction) {
      const allowed = openRangesByPosition[position] || [];
      const isInOpenRange = allowed.includes(hand);
      const winPercent = estimateWinChance(hand, position, isInOpenRange);
      const oddsLine = buildOddsNarrative(winPercent, position, userAction);

      const withOdds = (payload) => ({ ...payload, winPercent, oddsLine });

      // Special handling for big blind check/fold/raise
      if (position === 'BB') {
        if (userAction === 'CHECK') {
          if (isInOpenRange) {
            return withOdds({
              grade: 'B',
              good: true,
              context: 'Safe but passive.',
              recommended: 'Raising earns more than checking.',
              explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
            });
          } else {
            return withOdds({
              grade: 'A',
              good: true,
              context: 'Correct free check.',
              recommended: 'Checking is ideal.',
              explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
            });
          }
        }
        if (userAction === 'FOLD') {
          return withOdds({
            grade: 'D',
            good: false,
            context: 'Too tight.',
            recommended: 'Check instead of folding.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
        // Raises in BB fall through to the generic logic below
      }

      if (isInOpenRange) {
        if (userAction === 'RAISE') {
          return withOdds({
            grade: 'A',
            good: true,
            context: 'Solid open.',
            recommended: 'Raise / open this hand.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
        if (userAction === 'FOLD') {
          return withOdds({
            grade: 'F',
            good: false,
            context: 'Missed value.',
            recommended: 'Raise this hand instead of folding.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
        if (userAction === 'CALL') {
          return withOdds({
            grade: 'C',
            good: false,
            context: 'Passive limp.',
            recommended: 'Raise, don\'t limp.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
      } else {
        if (userAction === 'RAISE') {
          return withOdds({
            grade: 'D',
            good: false,
            context: 'Too loose here.',
            recommended: 'Folding is correct.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
        if (userAction === 'CALL') {
          return withOdds({
            grade: 'D',
            good: false,
            context: 'Passive call.',
            recommended: 'Fold or raise; limping invites trouble.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
        if (userAction === 'FOLD') {
          return withOdds({
            grade: 'A',
            good: true,
            context: 'Good discipline.',
            recommended: 'Folding is correct.',
            explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
          });
        }
      }

      return withOdds({
        grade: 'B',
        good: true,
        context: 'Reasonable.',
        recommended: 'Borderline, but not terrible.',
        explanation: buildPreflopExplanation({ hand, position, action: userAction, isInOpenRange }),
      });
    }

    // Scenario dealing
    const positions = ['UTG','MP','CO','BTN','SB','BB'];
    const positionLabels = {
      UTG: 'UTG (Early)',
      MP: 'MP (Middle)',
      CO: 'CO (Cutoff)',
      BTN: 'BTN (Button)',
      SB: 'SB (Small Blind)',
      BB: 'BB (Big Blind)',
    };

    const positionNotes = {
      BTN: { label: 'BTN – Dealer/Button', note: 'You act last after the flop, so you can play more hands here.' },
      CO: { label: 'CO – Cutoff / Late Position', note: 'Late position lets you react to others before committing chips.' },
      MP: { label: 'MP – Middle Position', note: 'Several players are left to act, so stick with steady hands.' },
      UTG: { label: 'UTG – First to Act', note: 'You speak first preflop; tighter choices keep you out of trouble.' },
      SB: { label: 'SB – Small Blind', note: 'You already posted a chip but act early later, so play solid starting hands.' },
      BB: { label: 'BB – Big Blind', note: 'You can check for free if no one raises, but plan carefully after the flop.' },
    };

    const ranks = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];
    const suits = [
      { symbol: '♠', color: 'black' },
      { symbol: '♥', color: 'red' },
      { symbol: '♦', color: 'red' },
      { symbol: '♣', color: 'black' },
    ];

    const scenarioPositionEl = document.getElementById('scenarioPosition');
    const handPreviewEl = document.getElementById('handPreview').querySelector('strong');
    const card1RankEl = document.getElementById('card1Rank');
    const card1SuitEl = document.getElementById('card1Suit');
    const card2RankEl = document.getElementById('card2Rank');
    const card2SuitEl = document.getElementById('card2Suit');

    const actionButtonsEl = document.getElementById('actionButtons');
    const callBtn = document.getElementById('callBtn');
    const checkBtn = document.getElementById('checkBtn');
    const primaryBtn = document.getElementById('primaryBtn');
    const autoDealToggle = document.getElementById('autoDealToggle');
    const autoDealTimerEl = document.getElementById('autoDealTimer');
    const autoDealBarEl = document.getElementById('autoDealBar');

    const gradeLetterEl = document.getElementById('gradeLetter');
    const gradeContextEl = document.getElementById('gradeContext');
    const recommendationEl = document.getElementById('recommendation');
    const explanationEl = document.getElementById('explanation');
    const oddsHeadlineEl = document.getElementById('oddsHeadline');
    const oddsSublineEl = document.getElementById('oddsSubline');
    const positionChipEl = document.getElementById('positionChip');
    const positionNoteEl = document.getElementById('positionNote');
    const tableSeats = document.querySelectorAll('.table-diagram .seat');

    let currentPosition = 'BTN';
    let currentCanonicalHand = 'AA';
    let selectedAction = null;
    let hasEvaluatedCurrent = false;
    let autoDealEnabled = false;
    let awaitingManualDeal = false;
    let autoDealTimeoutId = null;
    let lastEvalGrade = null;

    function randomFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function updatePositionHelper(position) {
      const info = positionNotes[position] || { label: position, note: '' };
      if (positionChipEl) {
        positionChipEl.textContent = info.label;
      }
      if (positionNoteEl) {
        positionNoteEl.textContent = info.note;
      }
      if (tableSeats && tableSeats.length) {
        tableSeats.forEach(seat => {
          seat.classList.toggle('active', seat.dataset.pos === position);
        });
      }
    }

    function setSelectedAction(action) {
      selectedAction = action;
      if (!actionButtonsEl) return;
      actionButtonsEl.querySelectorAll('.action-btn').forEach(b => {
        const disabled = b.classList.contains('disabled') || b.getAttribute('aria-disabled') === 'true';
        const isMatch = b.dataset.action === action;
        b.classList.toggle('selected', isMatch && !disabled);
      });
    }

    function updateActionsForPosition(forceDefault = false) {
      if (!callBtn || !checkBtn) return;
      const allActionBtns = actionButtonsEl.querySelectorAll('.action-btn');

      const isBigBlind = currentPosition === 'BB';
      const defaultAction = isBigBlind ? 'CHECK' : 'FOLD';

      if (forceDefault || (!hasEvaluatedCurrent && !selectedAction)) {
        selectedAction = defaultAction;
      }

      if (isBigBlind && selectedAction === 'CALL') {
        selectedAction = defaultAction;
      }
      if (!isBigBlind && selectedAction === 'CHECK') {
        selectedAction = defaultAction;
      }

      if (isBigBlind) {
        // Show Check, disable Call/Limp
        checkBtn.style.display = 'flex';
        callBtn.title = 'In the big blind with no raise, you don\'t call – checking is free.';
      } else {
        checkBtn.style.display = 'none';
        callBtn.title = 'Limping = calling the big blind preflop instead of raising.';

        if (selectedAction === 'CHECK') {
          selectedAction = defaultAction;
        }
      }

      // Disable all buttons once a decision has been evaluated
      // or disable Call/Limp specifically in the big blind.
      allActionBtns.forEach(b => {
        const isCallButton = b.dataset.action === 'CALL';
        const shouldDisable = hasEvaluatedCurrent || (isBigBlind && isCallButton);

        b.classList.toggle('disabled', shouldDisable);
        if (shouldDisable) {
          b.setAttribute('aria-disabled', 'true');
        } else {
          b.removeAttribute('aria-disabled');
        }

      });

      setSelectedAction(selectedAction);
    }

    function clearAutoDealTimer() {
      if (autoDealTimeoutId !== null) {
        clearTimeout(autoDealTimeoutId);
        autoDealTimeoutId = null;
      }
      if (autoDealTimerEl) {
        autoDealTimerEl.style.display = 'none';
      }
    }

    function setPrimaryBtnToEvaluate() {
      primaryBtn.innerHTML = 'Evaluate Decision<span>→</span>';
    }

    function setPrimaryBtnToDeal() {
      primaryBtn.innerHTML = 'Deal new hand<span>♠</span>';
    }

    function updateOddsDisplay(percent, narrative) {
      if (!oddsHeadlineEl || !oddsSublineEl) return;
      if (percent === null || percent === undefined) {
        oddsHeadlineEl.textContent = 'Win chance: –';
        oddsSublineEl.textContent = narrative || 'Pick an action to see how strong this hand is in this spot.';
        return;
      }

      const frequencyText = percentToFrequencyText(percent);
      oddsHeadlineEl.textContent = `Win chance: ${percent}% (${frequencyText})`;
      oddsSublineEl.textContent = narrative;
    }

    function resetResultBox() {
      gradeLetterEl.textContent = '–';
      gradeLetterEl.classList.remove('grade-badge-good', 'grade-badge-bad');
      gradeContextEl.textContent = 'Awaiting decision.';
      recommendationEl.textContent = 'Pick an action and evaluate to see feedback.';
      explanationEl.textContent = 'Lock in an action for this hand to get a recommendation and grade.';
      updateOddsDisplay(null, 'Pick an action to see how strong this hand is in this spot.');
    }

    function resetEvaluateState() {
      hasEvaluatedCurrent = false;
      awaitingManualDeal = false;
      lastEvalGrade = null;
      clearAutoDealTimer();
      setPrimaryBtnToEvaluate();
      primaryBtn.classList.remove('disabled');
      primaryBtn.removeAttribute('aria-disabled');
      primaryBtn.disabled = false;
    }

    function dealScenario() {
      // Random position
      currentPosition = randomFrom(positions);
      const label = positionLabels[currentPosition] || currentPosition;
      scenarioPositionEl.innerHTML = `POS: <strong>${label}</strong>`;
      updatePositionHelper(currentPosition);

      // Random distinct cards
      const r1 = randomFrom(ranks);
      const s1 = randomFrom(suits);
      let r2 = randomFrom(ranks);
      let s2 = randomFrom(suits);
      // Ensure not identical card
      while (r2 === r1 && s2.symbol === s1.symbol) {
        r2 = randomFrom(ranks);
        s2 = randomFrom(suits);
      }

      const suitedFlag = r1 === r2 ? '' : (s1.symbol === s2.symbol ? 's' : 'o');
      currentCanonicalHand = canonicalHand(r1, r2, suitedFlag);

      // Update visual cards
      card1RankEl.textContent = r1;
      card1SuitEl.textContent = s1.symbol;
      card1SuitEl.classList.toggle('red', s1.color === 'red');

      card2RankEl.textContent = r2;
      card2SuitEl.textContent = s2.symbol;
      card2SuitEl.classList.toggle('red', s2.color === 'red');

      handPreviewEl.textContent = currentCanonicalHand;

      // Clear selected action on new deal
      selectedAction = null;
      actionButtonsEl.querySelectorAll('.action-btn').forEach(b => b.classList.remove('selected'));
      resetResultBox();
      resetEvaluateState();
      updateActionsForPosition(true);
    }

      actionButtonsEl.addEventListener('click', (e) => {
        const btn = e.target.closest('.action-btn');
        if (!btn) return;
        if (btn.classList.contains('disabled') || btn.getAttribute('aria-disabled') === 'true') {
          // Ignore clicks on disabled buttons (e.g., Call/Limp in BB)
          return;
        }
        setSelectedAction(btn.dataset.action);
      });

    // Auto deal toggle
    if (autoDealToggle) {
      autoDealToggle.addEventListener('click', () => {
        autoDealEnabled = !autoDealEnabled;
        autoDealToggle.setAttribute('aria-pressed', autoDealEnabled ? 'true' : 'false');
        autoDealToggle.classList.toggle('active', autoDealEnabled);
        autoDealToggle.textContent = autoDealEnabled ? 'On' : 'Off';

        if (!autoDealEnabled) {
          clearAutoDealTimer();
          // If we had just graded under auto mode, switch to manual "Deal new hand" mode
          if (hasEvaluatedCurrent && !awaitingManualDeal) {
            awaitingManualDeal = true;
            primaryBtn.classList.remove('disabled');
            primaryBtn.removeAttribute('aria-disabled');
            primaryBtn.disabled = false;
            setPrimaryBtnToDeal();
          }
        } else if (hasEvaluatedCurrent) {
          // If we toggle on auto-deal after grading in manual mode, start the auto cadence only after A grades
          awaitingManualDeal = false;
          if (lastEvalGrade === 'A') {
            primaryBtn.classList.add('disabled');
            primaryBtn.setAttribute('aria-disabled', 'true');
            primaryBtn.disabled = true;
            startAutoDealCountdown();
          } else {
            clearAutoDealTimer();
            awaitingManualDeal = true;
            primaryBtn.classList.remove('disabled');
            primaryBtn.removeAttribute('aria-disabled');
            primaryBtn.disabled = false;
            setPrimaryBtnToDeal();
          }
        }
      });
    }

    function startAutoDealCountdown() {
      if (lastEvalGrade !== 'A') {
        return;
      }
      clearAutoDealTimer();
      if (!autoDealTimerEl || !autoDealBarEl) {
        autoDealTimeoutId = setTimeout(() => {
          dealScenario();
        }, 2000);
        return;
      }
      autoDealTimerEl.style.display = 'flex';
      autoDealBarEl.style.width = '0%';

      const start = performance.now();
      const duration = 2000;

      function step(now) {
        const elapsed = now - start;
        const progress = Math.min(elapsed / duration, 1);
        autoDealBarEl.style.width = (progress * 100) + '%';

        if (progress < 1 && autoDealEnabled && hasEvaluatedCurrent) {
          requestAnimationFrame(step);
        } else if (progress >= 1 && hasEvaluatedCurrent && autoDealEnabled) {
          dealScenario();
          clearAutoDealTimer();
        }
      }

      requestAnimationFrame(step);
    }

    primaryBtn.addEventListener('click', () => {
      // If we're in manual mode and waiting to deal the next hand,
      // this button acts as "Deal new hand"
      if (awaitingManualDeal && (!autoDealEnabled || lastEvalGrade !== 'A')) {
        dealScenario();
        return;
      }

      if (hasEvaluatedCurrent) {
        // Already graded this spot; ignore until a new hand is dealt
        return;
      }

      if (!selectedAction) {
        // Require the user to actually pick an action before grading
        gradeLetterEl.textContent = '–';
        gradeLetterEl.classList.remove('grade-badge-good', 'grade-badge-bad');
        gradeContextEl.textContent = 'Pick an action first.';
        recommendationEl.textContent = 'Choose Fold, Check, Call/Limp, or Raise.';
        explanationEl.textContent = 'The trainer only grades a decision after you lock in an action for this hand.';
        return;
      }

      const position = currentPosition;
      const hand = currentCanonicalHand;
      const evalResult = evaluatePreflopOpen(position, hand, selectedAction);

      lastEvalGrade = evalResult.grade;

      gradeLetterEl.textContent = evalResult.grade;
      gradeLetterEl.classList.toggle('grade-badge-good', evalResult.good);
      gradeLetterEl.classList.toggle('grade-badge-bad', !evalResult.good);
      gradeContextEl.textContent = evalResult.context;
      recommendationEl.textContent = `Recommended: ${evalResult.recommended}`;
      explanationEl.textContent = evalResult.explanation;
      updateOddsDisplay(evalResult.winPercent, evalResult.oddsLine);

      // Lock this scenario – only one graded decision per hand
      hasEvaluatedCurrent = true;
      updateActionsForPosition();

      if (autoDealEnabled && evalResult.grade === 'A') {
        // Auto mode: lock button, show timer, auto-deal after 2s when user nails an A
        primaryBtn.classList.add('disabled');
        primaryBtn.setAttribute('aria-disabled', 'true');
        primaryBtn.disabled = true;
        startAutoDealCountdown();
      } else {
        // Manual mode or auto paused on non-A grades: turn this button into "Deal new hand"
        clearAutoDealTimer();
        awaitingManualDeal = true;
        primaryBtn.classList.remove('disabled');
        primaryBtn.removeAttribute('aria-disabled');
        primaryBtn.disabled = false;
        setPrimaryBtnToDeal();
      }
    });

    // ---------- Pot odds helper ----------
    function approximateEquityFromOuts(outs) {
      // Rough rule-of-thumb with one card to come
      return outs * 2.2;
    }

    document.getElementById('calculateOddsBtn').addEventListener('click', () => {
      const potSize = parseFloat(document.getElementById('potSize').value || '0');
      const betSize = parseFloat(document.getElementById('betSize').value || '0');
      const outs = parseInt(document.getElementById('outs').value || '0', 10);

      const summaryEl = document.getElementById('oddsSummary');
      const explanationEl2 = document.getElementById('oddsExplanation');

      if (betSize <= 0 || potSize < 0 || outs < 0) {
        summaryEl.textContent = '–';
        explanationEl2.textContent = 'Please enter a valid pot, bet, and outs to calculate pot odds.';
        return;
      }

      const potAfterCall = potSize + betSize;
      const potOddsNeeded = (betSize / potAfterCall) * 100;
      const approxEquity = approximateEquityFromOuts(outs);

      const roundedPotOdds = Math.round(potOddsNeeded * 10) / 10;
      const roundedEquity = Math.round(approxEquity * 10) / 10;

      let verdict;
      if (approxEquity >= potOddsNeeded + 2) {
        verdict = 'Call looks +EV (ignoring implied/reverse implied odds).';
        summaryEl.textContent = 'Call';
      } else if (approxEquity <= potOddsNeeded - 2) {
        verdict = 'Call looks -EV; you are not winning often enough for this price.';
        summaryEl.textContent = 'Fold';
      } else {
        verdict = 'Very close spot; other factors (ranges, position, future streets) should decide.';
        summaryEl.textContent = 'Borderline';
      }

      explanationEl2.innerHTML =
        `Pot odds required: <strong>${roundedPotOdds.toFixed(1)}%</strong><br>` +
        `Approximate equity from outs: <strong>${roundedEquity.toFixed(1)}%</strong><br><br>` +
        verdict;
    });

    // Deal an initial scenario on load
    dealScenario();
  </script>
</body>
</html>
